import "./chunk-MJOZMRNF.js";

// node_modules/.pnpm/vuex-router-sync@6.0.0-rc.1_vue-router@4.4.5_vue@3.5.12_typescript@5.6.2___vuex@4.1.0_vue@3.5.12_typescript@5.6.2__/node_modules/vuex-router-sync/dist/vuex-router-sync.esm-browser.js
function sync(store, router, options) {
  const moduleName = (options || {}).moduleName || "route";
  store.registerModule(moduleName, {
    namespaced: true,
    state: cloneRoute(router.currentRoute.value),
    mutations: {
      ROUTE_CHANGED(_state, transition) {
        store.state[moduleName] = cloneRoute(transition.to, transition.from);
      }
    }
  });
  let isTimeTraveling = false;
  let currentPath;
  const storeUnwatch = store.watch((state) => state[moduleName], (route) => {
    const { fullPath } = route;
    if (fullPath === currentPath) {
      return;
    }
    if (currentPath != null) {
      isTimeTraveling = true;
      router.push(route);
    }
    currentPath = fullPath;
  }, { flush: "sync" });
  const afterEachUnHook = router.afterEach((to, from) => {
    if (isTimeTraveling) {
      isTimeTraveling = false;
      return;
    }
    currentPath = to.fullPath;
    store.commit(moduleName + "/ROUTE_CHANGED", { to, from });
  });
  return function unsync() {
    afterEachUnHook();
    storeUnwatch();
    store.unregisterModule(moduleName);
  };
}
function cloneRoute(to, from) {
  const clone = {
    name: to.name,
    path: to.path,
    hash: to.hash,
    query: to.query,
    params: to.params,
    fullPath: to.fullPath,
    meta: to.meta
  };
  if (from) {
    clone.from = cloneRoute(from);
  }
  return Object.freeze(clone);
}
export {
  sync
};
/*! Bundled license information:

vuex-router-sync/dist/vuex-router-sync.esm-browser.js:
  (*!
   /**
    * vuex-router-sync v6.0.0-rc.1
    * (c) 2021 Evan You
    * @license MIT
    *)
*/
//# sourceMappingURL=vuex-router-sync.js.map
