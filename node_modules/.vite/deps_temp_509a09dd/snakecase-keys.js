import {
  __assign,
  init_tslib_es6
} from "./chunk-BQB5CKKO.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-MJOZMRNF.js";

// node_modules/.pnpm/map-obj@4.3.0/node_modules/map-obj/index.js
var require_map_obj = __commonJS({
  "node_modules/.pnpm/map-obj@4.3.0/node_modules/map-obj/index.js"(exports, module) {
    "use strict";
    var isObject = (value) => typeof value === "object" && value !== null;
    var mapObjectSkip = Symbol("skip");
    var isObjectCustom = (value) => isObject(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
    var mapObject = (object, mapper, options, isSeen = /* @__PURE__ */ new WeakMap()) => {
      options = {
        deep: false,
        target: {},
        ...options
      };
      if (isSeen.has(object)) {
        return isSeen.get(object);
      }
      isSeen.set(object, options.target);
      const { target } = options;
      delete options.target;
      const mapArray = (array) => array.map((element) => isObjectCustom(element) ? mapObject(element, mapper, options, isSeen) : element);
      if (Array.isArray(object)) {
        return mapArray(object);
      }
      for (const [key, value] of Object.entries(object)) {
        const mapResult = mapper(key, value, object);
        if (mapResult === mapObjectSkip) {
          continue;
        }
        let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
        if (newKey === "__proto__") {
          continue;
        }
        if (options.deep && shouldRecurse && isObjectCustom(newValue)) {
          newValue = Array.isArray(newValue) ? mapArray(newValue) : mapObject(newValue, mapper, options, isSeen);
        }
        target[newKey] = newValue;
      }
      return target;
    };
    module.exports = (object, mapper, options) => {
      if (!isObject(object)) {
        throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
      }
      return mapObject(object, mapper, options);
    };
    module.exports.mapObjectSkip = mapObjectSkip;
  }
});

// node_modules/.pnpm/lower-case@2.0.2/node_modules/lower-case/dist.es2015/index.js
function lowerCase(str) {
  return str.toLowerCase();
}
var init_dist = __esm({
  "node_modules/.pnpm/lower-case@2.0.2/node_modules/lower-case/dist.es2015/index.js"() {
  }
});

// node_modules/.pnpm/no-case@3.0.4/node_modules/no-case/dist.es2015/index.js
function noCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
  var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  var start = 0;
  var end = result.length;
  while (result.charAt(start) === "\0")
    start++;
  while (result.charAt(end - 1) === "\0")
    end--;
  return result.slice(start, end).split("\0").map(transform).join(delimiter);
}
function replace(input, re, value) {
  if (re instanceof RegExp)
    return input.replace(re, value);
  return re.reduce(function(input2, re2) {
    return input2.replace(re2, value);
  }, input);
}
var DEFAULT_SPLIT_REGEXP, DEFAULT_STRIP_REGEXP;
var init_dist2 = __esm({
  "node_modules/.pnpm/no-case@3.0.4/node_modules/no-case/dist.es2015/index.js"() {
    init_dist();
    DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
    DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
  }
});

// node_modules/.pnpm/dot-case@3.0.4/node_modules/dot-case/dist.es2015/index.js
function dotCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return noCase(input, __assign({ delimiter: "." }, options));
}
var init_dist3 = __esm({
  "node_modules/.pnpm/dot-case@3.0.4/node_modules/dot-case/dist.es2015/index.js"() {
    init_tslib_es6();
    init_dist2();
  }
});

// node_modules/.pnpm/snake-case@3.0.4/node_modules/snake-case/dist.es2015/index.js
var dist_exports = {};
__export(dist_exports, {
  snakeCase: () => snakeCase
});
function snakeCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return dotCase(input, __assign({ delimiter: "_" }, options));
}
var init_dist4 = __esm({
  "node_modules/.pnpm/snake-case@3.0.4/node_modules/snake-case/dist.es2015/index.js"() {
    init_tslib_es6();
    init_dist3();
  }
});

// node_modules/.pnpm/snakecase-keys@8.0.1/node_modules/snakecase-keys/index.js
var require_snakecase_keys = __commonJS({
  "node_modules/.pnpm/snakecase-keys@8.0.1/node_modules/snakecase-keys/index.js"(exports, module) {
    var map = require_map_obj();
    var { snakeCase: snakeCase2 } = (init_dist4(), __toCommonJS(dist_exports));
    var PlainObjectConstructor = {}.constructor;
    module.exports = function(obj, options) {
      if (Array.isArray(obj)) {
        if (obj.some((item) => item.constructor !== PlainObjectConstructor)) {
          throw new Error("obj must be array of plain objects");
        }
      } else {
        if (obj.constructor !== PlainObjectConstructor) {
          throw new Error("obj must be an plain object");
        }
      }
      options = Object.assign({ deep: true, exclude: [], parsingOptions: {} }, options);
      return map(obj, function(key, val) {
        return [
          matches(options.exclude, key) ? key : snakeCase2(key, options.parsingOptions),
          val,
          mapperOptions(key, val, options)
        ];
      }, options);
    };
    function matches(patterns, value) {
      return patterns.some(function(pattern) {
        return typeof pattern === "string" ? pattern === value : pattern.test(value);
      });
    }
    function mapperOptions(key, val, options) {
      return options.shouldRecurse ? { shouldRecurse: options.shouldRecurse(key, val) } : void 0;
    }
  }
});
export default require_snakecase_keys();
//# sourceMappingURL=snakecase-keys.js.map
