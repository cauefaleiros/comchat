{
  "version": 3,
  "sources": ["../../.pnpm/@scmmishra+pico-search@0.5.4/node_modules/@scmmishra/pico-search/src/algorithms/jaroWinkler.ts", "../../.pnpm/@scmmishra+pico-search@0.5.4/node_modules/@scmmishra/pico-search/src/utils.ts", "../../.pnpm/@scmmishra+pico-search@0.5.4/node_modules/@scmmishra/pico-search/src/pico.ts"],
  "sourcesContent": ["/**\n * Calculates the Jaro-Winkler similarity between two strings.\n * @param {string} str1 - The first string to compare.\n * @param {string} str2 - The second string to compare.\n * @returns {number} A value between 0 and 1 indicating the similarity between the two strings, where 1 means the strings are identical and 0 means the strings are completely different.\n */\nexport default function jaroWinkler(str1: string, str2: string): number {\n  // Swap strings if str1 is shorter than string 2\n  if (str1.length < str2.length) {\n    [str1, str2] = [str2, str1];\n  }\n\n  const len1 = str1.length;\n  const len2 = str2.length;\n\n  if (len1 === 0) return 0.0;\n  if (len2 === 0) return 0.0;\n\n  const delta = Math.floor(len1 / 2) - 1;\n\n  // Flags for transpositions\n  const flag = Array(len2).fill(false);\n  const ch1Match = Array(len1).fill(\"\");\n\n  // Count number of matching characters\n  let matches = 0;\n  // Check if characters on both string matches\n  for (let i = 0; i < len1; i++) {\n    const ch1: string = str1[i];\n    for (let j = 0; j < len2; j++) {\n      const ch2: string = str2[j];\n      if (j <= i + delta && j + delta >= 1 && ch1 === ch2 && !flag[j]) {\n        flag[j] = true;\n        ch1Match[matches++] = ch1;\n        break;\n      }\n    }\n  }\n\n  if (!matches) {\n    return 0;\n  }\n\n  // Count number of transpositions (shared characters placed in different positions)\n  let transpositions = 0.0;\n  for (let i = 0, j = 0; j < len2; j++) {\n    if (flag[j]) {\n      if (str2[j] !== ch1Match[i]) {\n        transpositions++;\n      }\n      i++;\n    }\n  }\n\n  const mCount: number = matches;\n\n  // Jaro Similarity Formula simj = ( (m / length of s1) + (m / length of s2) + (m - t) / m ) / 3\n  const jaro: number =\n    (mCount / len1 + mCount / len2 + (mCount - transpositions / 2.0) / mCount) /\n    3.0;\n\n  // Length of common prefix between string up to 4 characters\n  let commonPrefix = 0.0;\n  const prefixLength = Math.min(4, len2);\n\n  for (let i = 0; i < prefixLength; i++) {\n    if (str1[i] === str2[i]) {\n      commonPrefix++;\n    }\n  }\n\n  return jaro + commonPrefix * 0.1 * (1.0 - jaro);\n}\n", "/**\n * Calculates the weighted average of a set of values.\n * @param {number[]} values - The values to be averaged.\n * @param {number[]} [weights] - The weights to be applied to the values.\n * @returns {number} The weighted average of the values.\n * @throws {Error} If the number of values is not equal to the number of weights.\n */\nexport function weightedAverage(values: number[], weights?: number[]): number {\n  let sum = 0;\n  let totalWeight = 0;\n\n  if (weights && values.length !== weights.length) {\n    throw new Error(\n      \"The number of values must be equal to the number of weights\",\n    );\n  }\n\n  for (let i = 0; i < values.length; i++) {\n    const weight = weights ? weights[i] : 1;\n    sum += values[i] * weight;\n    totalWeight += weight;\n  }\n\n  return sum / totalWeight;\n}\n\n/**\n * Clamps a number between a minimum and maximum value.\n * @param {number} value - The number to clamp.\n * @returns {number} The clamped value, which is between the minimum and maximum values.\n */\nexport function clamp(value: number): number {\n  return Math.max(0, Math.min(1, value));\n}\n\n/**\n * Splits a string into words, removes duplicates and empty words.\n * @param {string } value - The string to split and trim.\n * @returns {string[]} Returns an array of words, with duplicates and empty strings removed.\n */\nexport function splitAndTrim(value: string): string[] {\n  return value\n    .split(/\\s+/) // split by one or more whitespace characters\n    .filter((word, index, words) => word && words.indexOf(word) === index); // remove empty strings and duplicates\n}\n", "import jaroWinkler from \"./algorithms/jaroWinkler\";\nimport { clamp, weightedAverage, splitAndTrim } from \"./utils\";\n\ninterface SearchResult<T> {\n  object: T;\n  similarity: number;\n}\n\ntype KeyWithWeight = { name: string; weight: number };\ntype Keys = Array<KeyWithWeight | string>;\n\nconst BOOST_FACTOR = {\n  CONTAINS_MATCH: 1.2,\n  FIRST_SIMILARITY: 1.1,\n  // this value is less than contains match,\n  // so that if a word starts with the search term, but also contains it,\n  // it will be boosted less than if it only contains it\n  STARTS_WITH: 1.05,\n};\n\n/**\n * Searches for objects in an array based on a search term and a set of keys.\n * @param {T[]} objectsArray - The array of objects to search.\n * @param {string} searchTerm - The search term to match against the objects.\n * @param {Keys} keys - The keys to search in each object.\n * @param {PicoSearchConfig} [config] - Configuration options for the search.\n * @returns {T[]} An array of objects that match the search criteria, ordered by their similarity from the search term.\n */\nexport function picoSearch<T>(\n  objectsArray: T[],\n  searchTerm: string,\n  keys: Keys,\n  config: { threshold: number },\n): T[] {\n  if (!searchTerm || typeof searchTerm !== \"string\") {\n    return objectsArray;\n  }\n\n  const results: SearchResult<T>[] = [];\n  const threshold = config?.threshold ?? 0.8;\n  const trimmedSearchTerm = searchTerm.trim().toLowerCase();\n  const splitSearchTerm = splitAndTrim(trimmedSearchTerm);\n\n  objectsArray.forEach((obj) => {\n    const similarityScores: number[] = [];\n    const weightsInOrder: number[] = [];\n\n    keys.forEach((key) => {\n      let keyToCheck: string;\n      let weight = 1;\n\n      if (typeof key === \"string\") {\n        keyToCheck = key;\n      } else {\n        keyToCheck = key.name;\n        weight = key.weight;\n      }\n\n      weightsInOrder.push(weight);\n      const valueToSearch = (obj as any)[keyToCheck]?.trim().toLowerCase(); // skipcq: JS-0323\n\n      if (valueToSearch) {\n        const similarity = splitWordsAndRank(valueToSearch, splitSearchTerm);\n        similarityScores.push(similarity);\n      } else {\n        similarityScores.push(0);\n      }\n    });\n\n    const similarityForObject = weightedAverage(\n      similarityScores,\n      weightsInOrder,\n    );\n\n    if (similarityForObject >= threshold) {\n      results.push({ object: obj, similarity: similarityForObject });\n    }\n  });\n\n  results.sort((a, b) => b.similarity - a.similarity);\n\n  return results.map((result) => result.object);\n}\n\n/**\n * Splits a string into words, removes duplicates and empty words, and calculates the similarity score for each word.\n * Returns the maximum similarity score, with a boost if the highest matching word shows up first.\n * @param {string} valueToSearch - The string to split into words and rank.\n * @param {string} searchTerm - The search term to match against the words.\n * @returns {number} The maximum similarity score, with a boost if the highest matching word shows up first.\n */\nfunction splitWordsAndRank(valueToSearch: string, splitSearchTerm: string[]) {\n  const splitSearchCandidate = splitAndTrim(valueToSearch);\n\n  const splitScores = splitSearchTerm.map((searchWord) => {\n    const similarityValues = splitSearchCandidate.map((word) =>\n      getScoreForWord(word, searchWord),\n    );\n\n    const maxSimilarity = Math.max(...similarityValues);\n\n    // boost score if the highest matching word shows up first\n    return maxSimilarity === similarityValues[0]\n      ? maxSimilarity * BOOST_FACTOR.FIRST_SIMILARITY\n      : clamp(maxSimilarity);\n  });\n\n  return weightedAverage(splitScores);\n}\n\n/**\n * Calculates the similarity score between a word and a search term using the Jaro-Winkler algorithm.\n * If the word includes the search term, the score is boosted by a factor.\n * @param {string} word - The word to compare to the search term.\n * @param {string} searchTerm - The search term to compare to the word.\n * @returns {number} The similarity score between the word and the search term, possibly boosted.\n */\nfunction getScoreForWord(word: string, searchTerm: string): number {\n  const jwScore = jaroWinkler(word, searchTerm);\n\n  return word.includes(searchTerm)\n    ? jwScore * BOOST_FACTOR.CONTAINS_MATCH\n    : jwScore;\n}\n"],
  "mappings": "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",
  "names": ["jaroWinkler", "str1", "str2", "len1", "len2", "delta", "flag", "ch1Match", "matches", "i", "ch1", "j", "ch2", "transpositions", "mCount", "jaro", "commonPrefix", "prefixLength", "weightedAverage", "values", "weights", "sum", "totalWeight", "weight", "clamp", "value", "splitAndTrim", "word", "index", "words", "BOOST_FACTOR", "picoSearch", "objectsArray", "searchTerm", "keys", "config", "results", "threshold", "trimmedSearchTerm", "splitSearchTerm", "obj", "similarityScores", "weightsInOrder", "key", "keyToCheck", "valueToSearch", "similarity", "splitWordsAndRank", "similarityForObject", "a", "b", "result", "splitSearchCandidate", "splitScores", "searchWord", "similarityValues", "getScoreForWord", "maxSimilarity", "jwScore"]
}
